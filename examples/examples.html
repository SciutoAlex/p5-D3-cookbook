<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="keywords"
	content="processing, p5.js, P5js, grafica, grafica.js, javaScript, examples">
<title>Bridge Example</title>

<style media="screen">
	body {
		font-family:sans-serif;
	}
	.col {
		width:40%;
		float:left;
		margin:5%;
	}

	h5 {
		text-align:center;
	}

	canvas {
		max-width:100%;
	}

	.selected {
		stroke-width:3px;
		stroke:#000;
	}

	line {
		stroke-width:2px;
		stroke:black;
	}

	path {
		fill:none;
		stroke-width:2px;
		stroke:blue;
	}

	#d3Container {
		width:500px;
	}
	#d3Container div {
		border-bottom:0px solid gray;
		margin-bottom:10px;
		padding-bottom:10px;
	}

	#d3Container div:last-child {
		border-bottom:none;
	}

</style>
</head>

<body>
	<div class="col">
		<h5>p5 Canvas Container</h5>
		<div id="sketchContainer"></div>
	</div>

	<div class="col">
		<h5>D3 SVG Container</h5>
		<div id="d3Container">
			<h6>New Particle Colors. D3 event communicating to p5.</h6>
			<div id="d3ContainerColors"></div>
			<h6>Rate of New Particle Generation. Value defined by SVG path curve.</h6>
			<div id="d3ContainerLine"></div>
			<h6>Summary of All Current Particles. Array created by p5 back to D3.</h6>
			<div id="d3ContainerCountGrid"></div>

		</div>
	</div>

	<!-- JavaScript files -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.4.3/p5.min.js"></script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.js"></script>
	<script src="../src/lib.js"></script>

	<!-- p5 View -->
	<script>
		var p5Sketch = new p5(mySketch, "sketchContainer");

		function mySketch(p) {
			var maxSize = 20;
			var minSize = 10;
			var easing = .02;
			var currentSize = minSize;
			var targetR = maxSize*.75;
			var backgroundColor = 255;
			var resetColor = 100;
			var rateCounter = 0;

			var d3Module = p.D3Connect('color', 'size', 'speed', 'colorArray');
			var particleArray = [];
			p.setup = function() {
				p.createCanvas(500, 600);
				p.frameRate(30);
				p.noStroke();
				p.fill(130,23,200);
				i = -1;
				n = 00;
				while(++i < n) particleArray.push(new particle());
			}


			p.draw = function() {
				rateCounter++;
				var numberToCreate = p.map(p.int(d3Module.getValue('speed')), 10, 100, 0, 20);
				for (var i = 0; i < numberToCreate; i++) {
					particleArray.push(new particle(100));
				}
				// var lifeTime = p.map(p.int(d3Module.getValue('speed')), 10, 100, 90, 400);
				// particleArray.push(new particle(lifeTime));
				// particleArray.push(new particle(lifeTime));
				targetR = (Math.abs(targetR - currentSize) < 3) ? (Math.random() * (minSize-maxSize)) + minSize : targetR;


				//pulse background color on D3 Event firing using .wasFired(type) method.
				resetColor += 10;
				if(d3Module.wasFired('color')) {
					resetColor = 00;
				} else if (resetColor > backgroundColor) {
					resetColor = backgroundColor;
				}
				p.background(p.color(resetColor,resetColor,resetColor,10));

				//pass the current array of colored circles back to D3 using .setValue(type, val) method.
				if(rateCounter % 1 === 0) { // Only fire once every tenth of a second
					var colorArray = [];
					for (var i = 0; i < particleArray.length; i++) {
						colorArray.push(particleArray[i].color);
					}
					d3Module.setValue('colorArray', colorArray);
					colorArray = null;
				}
				var dr = targetR - currentSize;
				currentSize += dr * easing;


				//Cycle through the particles, update values, and draw.
				i = -1;
				n = particleArray.length;
				while(++i < n) {
					particleArray[i].update();
					particleArray[i].draw();
				}


				//Clear out dead particles. Must be a better way of doing this.
				var i = -1;
				var n = particleArray.length;
				var newArray = [];
				while(++i < n) {
					if(particleArray[i].getLife() > 1) {
						newArray.push(particleArray[i]);
					}
				}
				particleArray = newArray;


			}
			// This is what we'd like to have happen. Can't figure out how to get it
			// to work yet.
			// p.d3EventFired = function() {
			// 	console.log('fired');
			// }

			function particle(lifeTime) {
				this.color = d3.rgb(d3Module.getValue('color'));
				this.id = i;
				this.life = Math.random() * lifeTime;
				this.position = p.createVector(Math.random() * p.width, Math.random() * p.height);
			}

			particle.prototype.update = function() {
				this.life--;
				var noise = p.noise(this.position.x,this.position.y);
				this.position.x += Math.random() * noise*5 - noise*.5*5;
				this.position.y += Math.random() * noise*5 - noise*.5*5;
			}

			particle.prototype.draw = function() {

				p.fill(this.color.r, this.color.g, this.color.b);
				p.ellipse(this.position.x, this.position.y, currentSize, currentSize);
			}

			particle.prototype.getLife = function() {
				return this.life;
			}


		}
	</script>

	<!-- \\\\\\\\\\\ -->
	<!-- D3 controls -->
	<!-- /////////////// -->
	<script type="text/javascript">
	  var radius = 20;
		var d3Obj = d3.select('#d3ContainerColors').append('svg').attr('height', 100).attr('width', 500)
		  .append('g').attr('transform', 'translate(10,10)');

		var colorCircleData = d3.scale.category20().range();

		d3Obj.selectAll('circle')
			.data(colorCircleData)
			.enter()
			.append('circle')
			.attr('cy', function(d, i) {
				return radius + (i % 2) * radius * 2;
			})
			.attr('cx', function(d, i) { return (i+1) * (radius * 1.1); })
			.attr('r', radius)
			.style('fill', function(d) { return d; })
			.on('click', circleClicked)
			.on('mouseover', circleHovered)
			.on('mouseout', circleOut)

		function circleClicked(d, i) {
			p5connect.color(d);
			d3Obj.selectAll('circle').classed('selected', false);
			d3.select(this).classed('selected', true);
		}

		function circleHovered(d, i) {
			var d3This = d3.select(this);
			d3This.transition().duration(500).attr('r', radius + 3);

		}

		function circleOut(d, i) {
			var d3This = d3.select(this);
			d3This.transition().duration(500).attr('r', radius);
		}

		var d3Grid = d3.select('#d3ContainerCountGrid').append('svg').attr('height', 250).attr('width', 500)
			.append('g').attr('transform', 'translate(20,20)');
		p5connect.on('colorArray', function(d) {
			var radius = 4;
			var offsetSize = radius * 2 * 1.1;
			var rowSize = 50;
			var rowCount = 1;

			var join = d3Grid.selectAll('circle')
				.data(d);

			join.style('fill', function(d) {
				return d.toString();
			});

			join.exit().remove()

			join.enter()
				.append('circle')
				.attr('r', 0)
				.attr('cx', function(d,i) {
					return (i%rowSize) * offsetSize;
				})
				.attr('cy', function(d,i) {
					return Math.floor(i/rowSize) * offsetSize - 10;
				})
				.style('fill', function(d) {
					return d.toString();
				})
				.transition()
				.duration(300)
				.attr('r', radius)
				.attr('cy', function(d,i) {
					return Math.floor(i/rowSize) * offsetSize;
				});

		});

		//Line Graph
		//taken from http://bl.ocks.org/duopixel/3824661
		var svg = d3.select("#d3ContainerLine").append("svg").attr("width", 500).attr("height", 100);
		var svgWidth = parseInt(d3.select('#d3Container').style('width'), 10)
    var data = [18,18,5,2,4,6,13,18,19,20,20,6,3,2,0,0,0,0,0]
    var x = d3.scale.linear().domain([0, data.length-1]).range([0, svgWidth]);
    var y = d3.scale.linear().domain([0, 20]).range([90, 10]);
    var line = d3.svg.line()
      .interpolate("cardinal")
      .x(function(d,i) {return x(i);})
      .y(function(d) {return y(d);});


		svg.append('line')
			.attr('y1', y(0))
			.attr('y2', y(0))
			.attr('x1', 0)
			.attr('x2', svgWidth)
			.style('stroke-width', 2);

		var lines = svg.selectAll('.y-lines')
			.data([5,10,15,20])
			.enter()
			.append('g')
			.attr('transform', function(d) { return 'translate(0,' + y(d) + ')' });

		lines.append('line')
			.attr('y1', 0)
			.attr('y2', 0)
			.attr('x1', 0)
			.attr('x2', svgWidth-80)
			.style('stroke-width', 1)
			.style('stroke', '#ddd')

		lines.append('text')
			.text(function(d) { return d + " particles"; })
			.attr('x', svgWidth-75)
			.attr('y', 4)
			.style('font-size', 10);

		var xLine = svg.append('line')
			.attr('y1', y(0))
			.attr('y2', y(20))


    var path = svg.append("svg:path").attr("d", line(data));
    var circle =
        svg.append("circle")
          .attr("cx", 100)
          .attr("cy", 350)
          .attr("r", 6)
          .attr("fill", "red");

    var pathEl = path.node();
    var pathLength = pathEl.getTotalLength();
    var BBox = pathEl.getBBox();
    var scale = pathLength/BBox.width;
    var offsetLeft = document.getElementById("d3ContainerLine").offsetLeft;

		var x = 0;
    setInterval(function() {
      x += 3;
			if(x > svgWidth) {
				x = 0;
			}
      var beginning = x, end = pathLength, target;
      while (true) {
        target = Math.floor((beginning + end) / 2);
        pos = pathEl.getPointAtLength(target);
        if ((target === end || target === beginning) && pos.x !== x) {
            break;
        }
        if (pos.x > x)      end = target;
        else if (pos.x < x) beginning = target;
        else                break; //position found
      }
      circle
        .attr("opacity", 1)
        .attr("cx", x)
        .attr("cy", pos.y);
				p5connect.speed(100-pos.y);

			xLine
				.attr('x1', x)
				.attr('x2', x);
    }, 100);



	</script>
</body>
